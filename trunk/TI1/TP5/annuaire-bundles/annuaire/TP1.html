<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">
<head>
<meta http-equiv="content-type" content="application/xml+xhtml; charset=iso-8859-1" />
<meta http-equiv="content-language" content="fr" />
<link rel="stylesheet" type="text/css" media="screen" href="http://www710.univ-lyon1.fr/~lmedini/medini.css" />
<link rel="stylesheet" type="text/css" media="print" href="http://www710.univ-lyon1.fr/~lmedini/medini-print.css" />
<title>Master 2 TI - CAHD - TP 1</title>
</head>
<body>
<div id="principale">
<p style="font-weight: bold; text-align: center;">M2TI : Conception d'Applications Hétérogènes Distribuées</p>
<h1>TP 1 :&nbsp;conteneurs d'objets et&nbsp;inversion de contrôle</h1>
<h2>Objectifs pédagogiques</h2>
<p>Mettre en pratique les patterns IoC et Contexte afin de mieux comprendre le fonctionnement d'un framework. Mettre en place un outil configurable et capable de gérer le cycle de vie de ses composants.</p>

<h2>Application source</h2>
<p>Vous allez travailler sur une application de gestion de bookmarks de sites web dont une implémentation basique est accessible en clonant le d&eacute;p&ocirc;t <a href="http://mercurial.selenic.com/">Mercurial</a> suivant:</p>
<pre>hg clone https://forge.univ-lyon1.fr/hg/m2ti-ti1-2011-base</pre>
<p>Le dépôt contient un projet maven avec les sources de l'application, ainsi que des dépendances vers les bibliothèques utiles (voir plus loin).</p>
<p>Le&nbsp;diagramme de classes UML de cette application est disponible <a href="TP1/AnnuaireApp.jpg">là</a>. La fonction main de l'application est située dans la classe d'interface utilisateur (AnnuaireUI), qui instancie une classe contrôleur (Annuaire), laquelle instancie à son tour les autres classes de l'application, et notamment la classe d'accès aux données (SiteXMLDAO).</p>
<p>Intégrez les sources de cette application dans un projet Eclipse et exécutez-la.</p>
<p> Durant ce TP, vous allez modifier la structure de cette application pour qu'elle implémente les principes de l'inversion de contrôle, du contexte, de l'injection de dépendances et de la gestion du cycle de vie.</p>

<h2>0. Premières modifications</h2>
<p>L'application doit être considérée comme une application client-serveur sur un réseau. Le client est l'interface utilisateur, qui échange des requêtes et des réponses avec le serveur (l'annuaire).</p>
<p>Vous allez tout d'abord créer une arborescence de trois packages "tp1", "serveur" et "client", le premier étant le père des des suivants. Créez ensuite une classe contenant la fonction main, créant un serveur (Annuaire) et un client (AnnuaireUI) et passant à ce dernier une référence sur le serveur. Placez l'ensemble des classes de l'application dans les packages appropriés.</p>

<h2>1. Inversion de contrôle</h2>
<p>Vous allez maintenant mettre en place un conteneur. Pour cela, créez une classe Serveur qui masque au client l'ensemble des objets
côté serveur en lien avec l'annuaire et placez ces objets dans un conteneur.</p>
<h3>Indications</h3>
<ul>

<li>Conteneur :<br />
La classe Serveur instanciera un conteneur qui sera basé sur l'outil <a href="http://www.picocontainer.org/">PicoContainer</a>.
Le projet maven contient une dépendance vers la dernière version (2.13.6). La Javadoc est disponible en local <a href="TP1/picocontainer-2.13.6-javadoc.jar">là</a>. Commencez par lire la première page d'introduction à l'utilisation de cet outil, située <a href="http://www.picocontainer.org/introduction.html">ici</a>.</li>
<li>Arbre de dépendances :<br/>
Modifiez l'instanciation en chaîne d'une liste et d'un objet SiteXMLDAO dans le constructeur de l'annuaire ; modifiez ce constructeur pour que les dépendances se fassent sur des instances des objets ArrayList et SiteDAO (et non sur une valeur de nom de fichier permettant de créer un DAO)
<div class="bleu">Les dépendances seront alors les suivantes :<br />
Annuaire -&gt; ArrayList<br />
Annuaire -&gt; SiteXMLDAO<br />
SiteXMLDAO -&gt; valeur du nom du fichier XML (String)</div>
</li>
<li>Méthodes de la classe Annuaire :
<ul>
<li><span style="font-weight: bold;">méthodes de gestion du cycle de vie :</span> faites en sorte que la classe Annuaire implémente l'interface Startable et ajoutez-y les méthodes requises ; dans la méthode start(), rajoutez un affichage indiquant que le serveur a démarré, le type de classe d'implémentation de l'annuaire (aide : utilisez l'API Reflection) et l'instance du DAO qu'il utilise pour accéder aux données (aide : méthode toString() de l'instance). L'objectif est d'obtenir un affichage du style :<br />
<span class="code">Annuaire AnnuaireInit démarré. Objet d'accès aux données : tp1.serveur.site.SiteXMLDAO@95c083</span>
</li>
</ul>
</li>
<li>Méthodes de la classe Serveur :
<ul>
<li><span style="font-weight: bold;">constructeur :</span> il instanciera un DefaultPicoContainer, puis y rajoutera quatre composants avec des dépendances entre eux. Il récupèrera ensuite le composant annuaire instancié par le conteneur, le stockera dans une variable globale et appellera sa méthode start().</li>
<li><span style="font-weight: bold;">méthode (provisoire) de service :</span> getAnnuaire(), renvoyant au client une référence vers l'instance de l'annuaire.</li>
</ul>
</li>
</ul>
<p>Ressortez les objets métiers du package serveur de l'application et rangez-les dans des packages métier, à votre guise. Modifiez enfin les classes main et cliente pour que le client puisse contacter le serveur et appeler la méthode de service.</p>
<p class="bleu">&Agrave; ce stade, vous avez inversé le contrôle de vos objets métier en les plaçant dans un serveur (<span style="font-style: italic;">i.e.</span> un framework) qui se charge d'instancier, de gérer et d'utiliser ces objets.</p>

<h2>2. Isolation et uniformisation des objets côté serveur</h2>
<h3>2.1. Isolation</h3>
<p>Bien entendu, vous ne pouvez pas laisser le client accéder directement à l'instance de l'annuaire créée dans le conteneur. Pour cela, vous allez implémenter le paradigme requête-réponse :</p>
<ul>
<li>Modifiez la méthode de service du serveur pour qu'elle soit plus générique ; par exemple :<br /><br />public String traiteRequete(String commande, HashMap&lt;String, String&gt; parametres);<br /><br />où les éléments de la HashMap représentent les paires nom / valeur des
paramètres des requêtes</li>

<li>Dans l'annuaire, passez les trois méthodes add, remove et listSites en privé, et créez une méthode publique "process", qui appellera l'une de ces trois méthodes en fonction de la commande</li>
<li>Modifiez le code du client pour qu'il n'appelle plus que la méthode traiteRequete() du serveur</li>
<li>Renommez la classe Serveur en ServeurImpl, extrayez l'interface de service du serveur (que vous appellerez Serveur) et faites en sorte que le client ne connaisse plus que cette interface.</li>
</ul>
<p class="bleu">Remarquez que la classe ServeurImpl masque désormais complètement l'implémentation du traitement des requêtes par les objets métier. Il suffit au client de connaître son API pour utiliser l'annuaire.</p>

<h3>2.2. Uniformisation</h3>
<p>Plutôt que d'avoir un objet Annuaire qui répond à différentes requêtes, vous allez créer plusieurs objets sur le même modèle, mais traitant chacun un type de requête spécifique. Pour cela :</p>
<ul>
<li>Commencez par définir une interface et une classe abstraite reprenant les principales caractéristiques de l'annuaire : dépendances, implémentation de Startable et méthode de service process()</li>
<li>Créez quatre classes implémentant ce modèle et correspondant aux quatre méthodes de service add(), remove(), listeSites() et initSites()</li>
<li>Modifiez le constructeur du serveur pour que votre conteneur crée les composants correspondants aux instances de vos quatre nouvelles classes</li>
<li>Créez une méthode d' "aiguillage" des requêtes vers les instances de chacune de ces classes qui sera appelée par la méthode de service du serveur : la commande correspond au nom de la classe à appeler, comme un nom de ressource sur un serveur Web.</li>
</ul>
<p><span style="font-weight: bold;">Cycle de vie des composants :</span> Normalement, votre application ne doit pas fonctionner et vous renvoie une liste de sites vide à chaque opération. Vous constatez également que les instances du DAO sont différentes dans les messages d'initialisation des annuaires des méthodes de gestion du cycle de vie.<br />
Cela vient du fait que bien que les classes SiteXMLDAO et ArrayList soient des dépendances communes de tous les annuaires du conteneur, par défaut, celui-ci résout les dépendances en instanciant un objet différent pour chaque instance d'Annuaire. Toutefois, vous pouvez indiquez que vous souhaitez procéder autrement, c'est-à-dire qu'il "cache" les instances. Vous pouvez résoudre ce problème à deux niveaux :</p>
<ol>
<li>Au niveau du composant : en spécifiant la caractéristique "Cache" des composants que vous voulez cacher. Le plus simple est d'utiliser la méthode as() du conteneur, comme spécifié <a href="http://picocontainer.org/properties.html">ici</a>.</li>
<li>Au niveau du conteneur : en spécifiant un <a href="http://picocontainer.org/behaviors.html">comportement</a> global de type "Caching" pour tous les composants du conteneur dans le constructeur de celui-ci.</li>
</ol>
<p>Si vous choisissez la seconde solution, les annuaires seront cachés également, et vous n'aurez plus besoin de les stocker dans une variable globale. Par ailleurs, comme indiqué dans le warning du début de la <a href="http://picocontainer.org/lifecycle.html">page sur la gestion du cycle de vie des composants</a>, les méthodes start(), stop(), etc. sont conçues pour fonctionner avec des composants cachés, et vous pourrez appelez directement la méthode start() du conteneur pour qu'il démarre tous les composants qui implémentent Startable en même temps...</p>
<p class="bleu">&Agrave; ce stade, vous avez réalisé un outil équivalent à un conteneur de servlets. Il pourra fonctionner avec n'importe quelle classe d'implémentation correspondant à l'API de l'annuaire, à partir du moment où celle-ci est déclarée dans le serveur et correspond à une commande reconnue.</p>

<h2>3. Création d'un contexte applicatif</h2>
<p>Vous allez implémenter une classe qui permettra à chaque instance de Site créée d'accéder à ce DAO en respectant le pattern Context présenté en cours. Cela permettra par exemple d'utiliser un DAO instancié à l'extérieur du serveur (cas d'une connexion à un SGBD), ou de modifier par configuration le DAO utilisé pour gérer la persistence des données de l'application. Pour cela, vous allez rajouter un niveau d'indirection entre le conteneur (et ses composants) et les objets de type SiteDAO.</p>
<h3>3.1. Création du contexte</h3>
<p>Pour cela, vous allez créer une interface "SiteContext" et sa classe d'implémentation, de façon à ce que :</p>
<ul>
<li>le conteneur puisse indiquer une référence à un objet DAO existant</li>
<li>les différents composants puissent obtenir une référence sur ce DAO</li>
</ul>
<p>En clair, il s'agit d'une classe qui stocke une référence sur un DAO et possède deux accesseurs sur ce champ.</p>
<h3>3.2. Modification de l'arbre de dépendances</h3>
<p>Vous allez "sortir" le DAO du conteneur et le remplacer par une implémentation de SiteContext et modifier les composants du conteneur ayant une dépendance sur un objet SiteDAO pour qu'ils dépendent de SiteContext.</p>
<ul>
<li>Instanciez un DAO dans le main et  passez-en une référence dans le constructeur du serveur</li>
<li>Supprimez la création d'un objet SiteXMLDAO dans le conteneur de votre serveur et créez à la place une instance de ContextImpl en tant que composant de ce conteneur.</li>
<li>Modifiez les constructeurs de vos classes d'implémentation d'Annuaire (abstraites ou non), de façon à ce qu'ils prennent en paramètre un SiteContext et non plus un SiteDAO. Faites de même pour vos objets Site.</li>
<li>Veillez à remplacer les DAO dans tous les objets par des appels à la méthode correspondante (getDAO() ?) du contexte.</li>
</ul>
<h3>3.3. Initialisation et utilisation du contexte</h3>
<p>Enfin, dans le serveur, initialisez la variable dao dans votre contexte (méthode setDAO() ?) avant
le démarrage des différents composants Annuaire (méthode start()).</p>
<p>Faites tourner et testez votre application. Vous pouvez ensuite par exemple vous servir du contexte pour filtrer les appels au DAO et ne renvoyer la bonne référence que si la méthode est appelée par un Site (voir <a href="http://www.javalobby.org/java/forums/t67019.html">ici</a> ou <a href="http://stackoverflow.com/questions/421280/in-java-how-do-i-find-the-caller-of-a-method-using-stacktrace-or-reflection">là</a> pour des exemples de code sur comment trouver la classe appelant une méthode).</p>

<h3>3.4. Généralisation du contexte</h3>
<p>Actuellement, votre contexte n'est capable que de gérer un DAO. Modifiez-en l'API pour qu'il puisse stocker des références à tous les types d'objets et que ces objets soient accessibles par un nom (String). Tant qu'à faire, faites en sorte que ces noms soient indicatifs du fait qu'une référence est locale (interne au conteneur) un distante (externe).</p>

<p class="bleu">Vous venez de construire quelque chose de similaire à un annuaire JNDI, qui pernet aux composants d'accéder à des références sur des objets interne au conteneur ou distants. L'avantage de cette méthode est qu'elle fonctionne quelles que soient les implémentations du conteneur et du composant, et qu'elle permet d'utiliser plusieurs implémentations différentes d'un objet pour une même interface.</p>

<h2>4. Configuration de l'application</h2>
<p>Écrivez un fichier de configuration en XML et stockez-y les dépendances de valeurs (type d'objet DAO, nom du fichier de stockage) et les types d'objets Annuaire correspondant à chaque commande (à la manière des fichiers web.xml utilisés dans les conteneurs de servlets). Utilisez ces données dans la classe Serveur lors de l'instanciation des éléments des conteneurs et du contexte.</p>
</div>
<div id="validation">
	<a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Strict" style="height: 31px; width: 88px" /></a>
</div>
</body>
</html>
